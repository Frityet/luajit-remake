#pragma once

#include "bit_vector_utils.h"
#include "common_utils.h"

namespace DeegenBytecodeBuilder {
class BytecodeDecoder;
}   // namespace DeegenBytecodeBuilder

namespace dfg {

// Each BytecodeSpeculativeInliningTrait records information about a certain call site of a certain bytecode kind
//
// These information are generated by Deegen
//
struct BytecodeSpeculativeInliningTrait
{
    // Whether this is a in-place call
    //
    bool m_isInPlaceCall;
    // Whether this is required to be a proper tail call
    //
    bool m_isTailCall;
    // Whether we need to append the VariadicResults to the end of the argument sequence
    //
    bool m_appendsVariadicResultsToArgs;
    // Whether the function prologue can use a reduced set of input edges
    //
    bool m_hasReducedReadInfo;
    // Whether the argument sequence contains a range
    //
    bool m_hasRangeArgs;

    // Whether the return continuation of this call only contains trivial logic thus can be converted to data flow
    //
    enum class TrivialRCKind : uint8_t
    {
        NotTrivial,
        ReturnKthResult,
        StoreFirstKResults,
        StoreAllAsVariadicResults
    };
    TrivialRCKind m_rcTrivialness;

    // A prologue node produces an direct output if it is a closure call: the FunctionObject to be called (an UNBOXED pointer),
    // and no direct output if it is a direct call.
    // It may also have extra outputs: these are the arguments computed inside the prologue and passed to the call
    //
    // The number of extra outputs of the prologue node
    //
    uint32_t m_numExtraOutputs;

    // If the argument sequence contains a range, the sequence is the following:
    // 1. m_rangeLocationInArgs values outputted by the prologue
    // 2. The range of values on the stack frame
    // 3. The rest of the values outputted by the prologue
    //
    uint32_t m_rangeLocationInArgs;

    struct RangeArgInfo
    {
        size_t m_rangeStart;
        size_t m_rangeLen;
    };

    using RangeArgInfoGetter = RangeArgInfo(*)(DeegenBytecodeBuilder::BytecodeDecoder* decoder, size_t bcPos);
    RangeArgInfoGetter m_rangeInfoGetter;

    struct TrivialRCInfo
    {
        // Records the k for ReturnKthResult and StoreFirstKResults
        //
        size_t m_num;
        // Records the range start ordinal for StoreFirstKResults
        //
        size_t m_rangeStart;
    };

    // Only populated if m_rcTrivialness is ReturnKthResult and StoreFirstKResults
    //
    using TrivialRCInfoGetter = TrivialRCInfo(*)(DeegenBytecodeBuilder::BytecodeDecoder* decoder, size_t bcPos);
    TrivialRCInfoGetter m_trivialRCInfoGetter;

    // Only populated if m_hasReducedReadInfo is true
    //
    // allZeroBv must be an all-zero vector of length #locals. It will not be changed after the call.
    //
    using PrologueReadInfoGetter = void(*)(DeegenBytecodeBuilder::BytecodeDecoder* decoder,
                                           size_t bcPos,
                                           TempBitVector& allZeroBv,
                                           TempVector<uint32_t>& result /*out*/);
    PrologueReadInfoGetter m_prologueReadInfoGetter;

    static void AssertBitVectorIsAllZero(const TempBitVector& TESTBUILD_ONLY(bv))
    {
#ifdef TESTBUILD
        for (size_t i = 0; i < bv.GetAllocLength(); i++)
        {
            TestAssert(bv.m_data[i] == 0);
        }
#endif
    }

    static void ALWAYS_INLINE AddToListIfNotExist(TempVector<uint32_t>& result /*inout*/, TempBitVector& bv /*inout*/, size_t localOrd)
    {
        TestAssert(localOrd < bv.m_length);
        if (!bv.IsSet(localOrd))
        {
            bv.SetBit(localOrd);
            result.push_back(SafeIntegerCast<uint32_t>(localOrd));
        }
    }

    static void ALWAYS_INLINE ResetBitVectorGivenList(TempBitVector& bv /*inout*/, const TempVector<uint32_t>& result)
    {
        for (uint32_t localOrd : result)
        {
            TestAssert(bv.IsSet(localOrd));
            bv.ClearBit(localOrd);
        }
        AssertBitVectorIsAllZero(bv);
    }
};

struct BytecodeSpeculativeInliningInfo
{
    constexpr BytecodeSpeculativeInliningInfo()
        : m_isInitialized(false)
        , m_numCallSites(0)
        , m_callIcOffsetInSlowPathData(0)
        , m_info(nullptr)
    { }

    constexpr BytecodeSpeculativeInliningInfo(uint8_t numCallSites,
                                              uint16_t callIcOffsetInSlowPathData,
                                              const BytecodeSpeculativeInliningTrait* const* info)
        : m_isInitialized(true)
        , m_numCallSites(numCallSites)
        , m_callIcOffsetInSlowPathData(callIcOffsetInSlowPathData)
        , m_info(info)
    { }

    // Whether the record has been properly populated, for assertion purpose only
    //
    bool m_isInitialized;

    // The total number of call sites in this bytecode
    //
    uint8_t m_numCallSites;

    // The offset of the IC site array in SlowPathData
    //
    uint16_t m_callIcOffsetInSlowPathData;

    // An array of length m_numCallSites, the information with regard to each trait.
    // If m_info is nullptr, it means this bytecode is not eligible for inlining at all.
    // If an entry in m_info is nullptr, it means this callsite is not eligible for inlining.
    //
    const BytecodeSpeculativeInliningTrait* const* m_info;
};

}   // namespace dfg
